;;; visfilt.el --- generic visual filter

;; Copyright (C) 2012 Kalle Kankare

;; Author: Kalle Kankare <kalle.kankare@iki.fi>
;; Maintainer: Kalle Kankare <kalle.kankare@iki.fi>
;; Created: 15 Jul 2012
;; Keywords: display utility, filtering
;; Version: 0.0

;; This file is not part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; TODO

;;; Code:

(eval-when-compile
  (require 'cl))

(defvar visfilt-max-items nil)
(defvar visfilt-buffer-name "*visfilt*")
(defvar visfilt-search-data nil)
(defvar visfilt-search-data-pos nil)
(defvar visfilt-search-string "")
(defvar visfilt-search-key-list
  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_")
(defvar visfilt-choose-callback nil)
(defvar visfilt-search-string-face 'hi-yellow)

(defvar visfilt-header-format-function #'visfilt-header-default-format-function
  "A function to insert a header into visfilt. The prototype is
the following:

(lambda (&optional search-str count))

if both arguments are nil, return the number of rows that the
header occupies. Look at `visfilt-header-default-format-function' 
for an example." )

(defvar visfilt-display-line-function #'car
  "Function to parse a displayable line from an element of a list
generated by the `visfilt-choose-filter-function'. This can be
used to add formatting to the displayed lines. Each element
should be the following format:

(\"displayable string\" position ...)

First one must be a string. It is displayed by default on
screen. The second one depends on the type of filter-function. It
can be a list index or a buffer position for example.")

(defvar visfilt-filter-function-alist
  '((cons . (visfilt-filter-list))
    (buffer . (visfilt-filter-buffer))
    (string . (visfilt-filter-buffer (lambda (arg) (get-buffer arg)))))
  "List of types that are supported for filtering. The elements
of the alist are of the following format:

(type . (filtering-function conversion-function))

The general functionality is that a variable of type `type' is
given to the defun `visfilt-choose'. It is possibly converted
to a proper format using `conversion-function' if it is not
nil. The argument is then filtered using the
`filtering-function'.

Type is that of reported by `type-of'. Filtering-function is
documented in with `vislist-choose-filter-function'. The
`conversion-function' gets the argument `elements' of
`visfilt-choose' and returns it in the proper format or nil, if
it is invalid.")

;; internal variables
(defvar visfilt-choose-filter-function nil
  "A function with the following arguments (elements count
search-str). Filters the `elements' with the `search-str' at
maximum of `count' times. `elements' can be anything. Look for
examples at `visfilt-filter-list' and `visfilt-filter-buffer'.

This is set by defun `visfilt-choose' to a value from
`vislist-filter-function-alist'.")

(defvar visfilt-displayed-elements nil)

(defvar visfilt-mode-map
  nil
  "Keymap for visfilt mode.")

;; core functionality

(defun visfilt-regenerate-keymap() 
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)

    (define-key map (kbd "C-g") 'kill-this-buffer)
    (define-key map (kbd "<RET>") 'visfilt-run-callback)
    (define-key map (kbd "<backspace>") 'visfilt-search-string-decrement)

    (dolist (k (string-to-list visfilt-search-key-list))
      (define-key map (read-kbd-macro (char-to-string k))
	'visfilt-search-string-modify))

    (setq visfilt-mode-map map)))

;; generate the keymap for the first time
(visfilt-regenerate-keymap)

(defun visfilt-header-default-format-function (&optional searchstr count)
  (if (and (null searchstr) (null count))
      2
    (format "String(%d): %s\n" count searchstr)))

(defun visfilt-run-callback ()
  "When an element is selected, this function runs the callback
function that is stored in `visfilt-choose-callback'."

  (interactive)
  (let ((string (filter-buffer-substring (point-at-bol) (point-at-eol)))
	(callback visfilt-choose-callback)
	(pos (line-number-at-pos))
	(elem (nth (- (line-number-at-pos) (funcall visfilt-header-format-function)) 
		   visfilt-displayed-elements)))

    (kill-buffer (current-buffer))
    (when (functionp callback)
      ;; (message "current line %d ja tällöin %s" pos elem)
      (funcall callback elem))))

(defun visfilt-update ()
  "Updates the visfilt buffer with a search string."
  (erase-buffer)
  (let* ((max-items (or visfilt-max-items 
			(- (window-height) 1 
			   (funcall visfilt-header-format-function))))
	 (displayed 
	  (funcall visfilt-choose-filter-function 
		   visfilt-search-data max-items 
		   (visfilt-escape-re visfilt-search-string)))
	 start-point)

    ;; insert the header
    (insert (funcall visfilt-header-format-function 
		     (visfilt-escape-re visfilt-search-string) (length displayed)))
    (setq start-point (point))

    (setq visfilt-displayed-elements displayed)

    ;; insert the filtered elements
    (dolist (line displayed)
      (insert (concat (funcall visfilt-display-line-function line) "\n")))

    ;; apply the font-face
    (set-buffer-modified-p nil)
    (goto-char (point-min))
    (if (> (length visfilt-search-string) 0)
	(hi-lock-face-buffer 
	 visfilt-search-string visfilt-search-string-face))
    (goto-char start-point)))

(defun visfilt-escape-re (string)
  "Escape regular expression syntax in a string"
  (mapconcat #'(lambda (x)
		(setq x (char-to-string x))
		(if (string-match "[.+?|*\\^$[]" x)
		    (concat "\\" x)
		  x))
	     string ""))

(defun visfilt-search-string-modify (&optional decrement)
  "Either adds the `last-command-event' as a string to the search
string or if decrement is not nil, then removes one character. In any case
removes the previous search string overlay face."
  (interactive)

  (if (> (length visfilt-search-string) 0)
      (hi-lock-unface-buffer visfilt-search-string))
  (if decrement
      (let ((len (length visfilt-search-string)))
	(if (> len 0)
	    (setq visfilt-search-string 
		  (subseq visfilt-search-string 0 
			  (min (- len 1) len)))))
    (setq visfilt-search-string (concat visfilt-search-string 
					(char-to-string last-command-event))))
  (visfilt-update))

(defun visfilt-search-string-decrement ()
  "Decrements the visfilt-search-string by one character." 
  (interactive)
  (visfilt-search-string-modify t))

(define-derived-mode visfilt-mode nil "Visual list"
  "Visual list mode.
  \\{visfilt-mode-map}"
)

(defun visfilt-choose (elements callback)
  "Choose an element from `elements' using visfilt and return the
element through callback `callback'. "
  (interactive)

  ;; select the appropriate filter to the given argument
  (let* ((filter-elem (assoc (type-of elements) visfilt-filter-function-alist))
	(convert (caddr filter-elem)))
    (when (not filter-elem)
      (error "unsupported type for the first argument"))

    (setq visfilt-choose-filter-function (cadr filter-elem))

    (when convert
      (setq elements (funcall convert elements))
      (when (not elements)
	(error "conversion failed"))))

  (switch-to-buffer (get-buffer-create (generate-new-buffer-name visfilt-buffer-name)) t)
  (visfilt-mode)

  (make-local-variable 'visfilt-mode-map)
  (make-local-variable 'visfilt-search-string)
  (make-local-variable 'visfilt-search-data)
  (make-local-variable 'visfilt-search-data-pos)
  (make-local-variable 'visfilt-choose-callback)
  (make-local-variable 'visfilt-choose-filter-function)
  (make-local-variable 'visfilt-displayed-elements)
  (make-local-variable 'visfilt-display-line-function)

  (visfilt-regenerate-keymap)
  (use-local-map visfilt-mode-map)

  (setq visfilt-search-string "")
  (setq visfilt-search-data elements)
  (setq visfilt-choose-callback callback)

  (setq truncate-lines t)

  ;; (message "callback on täällä %s" callback)
  (hi-lock-mode 1)
  (visfilt-update))


;; peripheral functionality

;;TODO ekassa tapauksessa formaatti myös oikeaksi
(defun visfilt-filter-list (elements count search-str)
  "Filters a list with the `search-str'."
  (if (>= (length visfilt-search-string) 0)
      (let (matched (pos 0))
	(every  '(lambda (x) 
		   (when (string-match search-str x)
		     (push (list x pos) matched)
		     (setq count (1- count)))
		   (setq pos (1+ pos))
		   (if (<= count 0)
		       nil
		     t))
		elements)
	matched)
    (subseq visfilt-search-data 0 count)))

;; move-to-window-line 0
;; line-number-at-pos 

(defun visfilt-filter-buffer (buffer count search-str)
  "Filters a buffer with the `search-str'."
  (let (ret)
    (with-current-buffer buffer
      (goto-char (point-min))
      (when (> (length search-str) 0)
	(while (> count 0)
	  (let ((pos (re-search-forward search-str nil t nil)))
	    (if pos
		(add-to-list 'ret 
			     (list (buffer-substring (point-at-bol) (point-at-eol))
				   (line-number-at-pos)) t)
	      (setq count 0))
	    (setq count (1- count))
	    )))
      ret)))


(provide 'visfilt)
