;; -*- lexical-binding: t -*-
;;; visfilt.el --- generic visual filter

;; Copyright (C) 2012 Kalle Kankare

;; Author: Kalle Kankare <kalle.kankare@iki.fi>
;; Maintainer: Kalle Kankare <kalle.kankare@iki.fi>
;; Created: 15 Jul 2012
;; Keywords: display utility, filtering
;; Version: 0.0

;; This file is not part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; TODO

;;; Code:

(require 'cl-lib)

(defvar visfilt-max-items nil)
(defvar visfilt-buffer-name "*visfilt*")
(defvar visfilt-search-data nil)
(defvar visfilt-search-data-pos nil)
(defvar visfilt-search-string "")
(defvar visfilt-search-key-list
  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_")
(defvar visfilt-choose-callback nil)
(defvar visfilt-search-string-face 'hi-yellow)

(defvar visfilt-header-format-function #'visfilt-header-default-format-function
  "A function to insert a header into visfilt. The prototype is
the following:

  (lambda (&optional search-str count))

if both arguments are nil, return the number of rows that the
header occupies. Look at `visfilt-header-default-format-function'
for an example." )

(defvar visfilt-display-line-function #'car
  "Function to parse a displayable line from an element of a list
generated by the `visfilt-choose-filter-function'. This can be
used to add formatting to the displayed lines. Each element
should be the following format:

  (\"displayable string\" position ...)

First one must be a string. It is displayed by default on
screen. The second one depends on the type of filter-function. It
can be a list index or a buffer position for example.")

(defvar visfilt-filter-function-alist
  '((cons . (visfilt-filter-list))
    (buffer . (visfilt-filter-buffer))
    (string . (visfilt-filter-buffer (lambda (arg) (get-buffer arg)))))
  "List of types that are supported for filtering. The elements
of the alist are of the following format:

  (type . (filtering-function conversion-function))

The general functionality is that a variable of type `type' is
given to the defun `visfilt-choose'. It is possibly converted
to a proper format using `conversion-function' if it is not
nil. The argument is then filtered using the
`filtering-function'.

Type is that of reported by `type-of'. Filtering-function is
documented in with `vislist-choose-filter-function'. The
`conversion-function' gets the argument `elements' of
`visfilt-choose' and returns it in the proper format or nil, if
it is invalid.")

;; internal variables
(defvar visfilt-choose-filter-function nil
  "A function with the following arguments (elements count
search-str). Filters the `elements' with the `search-str' at
maximum of `count' times. `elements' can be anything. Look for
examples at `visfilt-filter-list' and `visfilt-filter-buffer'.

This is set by defun `visfilt-choose' to a value from
`vislist-filter-function-alist'.")

(defvar visfilt-displayed-elements nil)

(defvar visfilt-mode-map
  nil
  "Keymap for visfilt mode.")

;; core functionality

(defun visfilt-regenerate-keymap()
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)

    (define-key map (kbd "C-g") 'kill-this-buffer)
    (define-key map (kbd "<RET>") 'visfilt-run-callback)
    (define-key map (kbd "<backspace>") 'visfilt-search-string-decrement)

    (dolist (k (string-to-list visfilt-search-key-list))
      (setq k (char-to-string k))
      (when (string= k " ") (setq k "SPC"))
      (define-key map (read-kbd-macro k)
	'visfilt-search-string-modify))

    (setq visfilt-mode-map map)))

;; generate the keymap for the first time
(visfilt-regenerate-keymap)

(defun visfilt-header-default-format-function (&optional searchstr count)
  (if (and (null searchstr) (null count))
      2
    (format "String(%d): %s\n" count searchstr)))

(defun visfilt-run-callback ()
  "When an element is selected, this function runs the callback
function that is stored in `visfilt-choose-callback'."

  (interactive)
  (let ((string (filter-buffer-substring (point-at-bol) (point-at-eol)))
	(callback visfilt-choose-callback)
	(pos (line-number-at-pos))
	(elem (nth (- (line-number-at-pos) (funcall visfilt-header-format-function))
		   visfilt-displayed-elements)))

    (kill-buffer (current-buffer))
    (when (functionp callback)
      ;; (message "current line %d ja tällöin %s" pos elem)
      (funcall callback elem))))

(defun visfilt-update ()
  "Updates the visfilt buffer with a search string."
  (setq buffer-read-only nil)
  (erase-buffer)
  (let* ((max-items (or visfilt-max-items
			(- (window-height) 1
			   (funcall visfilt-header-format-function))))
	 (displayed
	  (funcall visfilt-choose-filter-function
		   visfilt-search-data max-items
		   (regexp-quote visfilt-search-string)))
	 start-point)

    ;; insert the header
    (insert (funcall visfilt-header-format-function
		     (regexp-quote visfilt-search-string) (length displayed)))
    (setq start-point (point))

    (setq visfilt-displayed-elements displayed)

    ;; insert the filtered elements
    (dolist (line displayed)
      (insert (concat (funcall visfilt-display-line-function line) "\n")))

    ;; apply the font-face
    (set-buffer-modified-p nil)
    (goto-char (point-min))
    (if (> (length visfilt-search-string) 0)
	(hi-lock-face-buffer
	 (regexp-quote visfilt-search-string) visfilt-search-string-face))
    (goto-char start-point)
  (setq buffer-read-only t)))

(defun visfilt-search-string-modify (&optional decrement)
  "Either adds the `last-command-event' as a string to the search
string or if decrement is not nil, then removes one character. In any case
removes the previous search string overlay face."
  (interactive)

  (if (> (length visfilt-search-string) 0)
      (hi-lock-unface-buffer (regexp-quote visfilt-search-string)))
  (if decrement
      (let ((len (length visfilt-search-string)))
	(if (> len 0)
	    (setq visfilt-search-string
		  (cl-subseq visfilt-search-string 0
			  (min (- len 1) len)))))
    (setq visfilt-search-string (concat visfilt-search-string
					(char-to-string last-command-event))))
  (visfilt-update))

(defun visfilt-search-string-decrement ()
  "Decrements the visfilt-search-string by one character."
  (interactive)
  (visfilt-search-string-modify t))

(define-derived-mode visfilt-mode nil "VF"
  "Visual filtering mode.
  \\{visfilt-mode-map}"
)

(defun visfilt-choose (elements callback)
  "Choose an element from `elements' using visfilt and return the
element through callback `callback'. "
  (interactive)

  ;; select the appropriate filter to the given argument
  (let* ((filter-elem (assoc (type-of elements) visfilt-filter-function-alist))
	(convert (cl-caddr filter-elem)))
    (when (not filter-elem)
      (error "visfilt: unsupported type for the first argument"))

    (setq visfilt-choose-filter-function (cadr filter-elem))

    (when convert
      (setq elements (funcall convert elements))
      (when (not elements)
	(error "visfilt: conversion to a supported type failed"))))

  (switch-to-buffer (get-buffer-create (generate-new-buffer-name visfilt-buffer-name)) t)
  (visfilt-mode)

  (make-local-variable 'visfilt-mode-map)
  (make-local-variable 'visfilt-search-string)
  (make-local-variable 'visfilt-search-data)
  (make-local-variable 'visfilt-search-data-pos)
  (make-local-variable 'visfilt-choose-callback)
  (make-local-variable 'visfilt-choose-filter-function)
  (make-local-variable 'visfilt-displayed-elements)
  (make-local-variable 'visfilt-display-line-function)

  (visfilt-regenerate-keymap)
  (use-local-map visfilt-mode-map)

  (setq visfilt-search-string "")
  (setq visfilt-search-data elements)
  (setq visfilt-choose-callback callback)

  (setq truncate-lines t)

  ;; (message "callback on täällä %s" callback)
  (hi-lock-mode 1)
  (visfilt-update))


;; peripheral functionality

(defun visfilt-filter-list (elements count search-str)
  "Filters a list with the `search-str'."
  (cl-loop for e in elements
	   counting e into pos
	   when (and (string-match search-str e) (> (setq count (1- count)) 0))
	   collect (list e pos)))

(defun visfilt-filter-buffer (buffer count search-str)
  "Filters a buffer with the `search-str'."
  (let (ret
	(search-str-p (> (length search-str) 0)))
    (with-current-buffer buffer
      (goto-char (point-min))
      (while (> count 0)
	(let ((pos (if search-str-p
		       (re-search-forward search-str nil t nil)
		     (point))))
	  (if pos
	      (progn
		(setq ret (cons (list (buffer-substring (point-at-bol) (point-at-eol))
				   (line-number-at-pos)) ret))
		(goto-char (1+ (point-at-eol))))
	    (setq count 0))
	  (setq count (1- count))))
      (nreverse ret))))


(provide 'visfilt)

;;; visfilt.el ends here
