;; generic visual filter, similar to eassist

;; TODO common lisp style optional arguments: 
;;   :parse parses the matchable string from each element of the list
;;   :display used to display found elements (args: string pos)
;;   :header string to put on top of the visfilt buffer

;; Speed optimization: when writing additional character to buffer and count
;; is lower than max-items -> only search within the already found

(require 'cl)

(defvar visfilt-max-items nil)
(defvar visfilt-buffer-name "*visfilt*")
(defvar visfilt-search-data nil)
(defvar visfilt-search-data-pos nil)
(defvar visfilt-search-string "")
(defvar visfilt-search-key-list
  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_")
(defvar visfilt-choose-callback nil)
(defvar visfilt-search-string-face 'hi-yellow)

(defvar visfilt-header-format-function #'visfilt-header-default-format-function
  "A function to insert a header into visfilt. The prototype is
  the following:

  (lambda (&optional search-str count))

  if both arguments are nil, return the number of rows that the
  header occupies. Look at `visfilt-header-default-format-function' 
  for an example." )

(defvar visfilt-display-line-function #'car
  "Function to parse a displayable line from an element of a list
generated by the `visfilt-choose-filter-function'. This can be
used to add formatting to the displayed lines. Each element
should be the following format:

  (\"displayable string\" position ...)

First one must be a string. It is displayed by default on
screen. The second one depends on the type of filter-function. It
can be a list index or a buffer position for example.")

(defvar visfilt-filter-function-alist
  '(
    (listp . (visfilt-filter-list))
    (bufferp . (visfilt-filter-buffer))
    (stringp . (visfilt-filter-buffer (lambda (item)
					
)))
    
  
  )
)

;; internal variables
(defvar visfilt-choose-filter-function nil
  "A function with the following arguments (elements count
search-str). Filters the `elements' with the `search-str' at
maximum of `count' times. `elements' can be a buffer or a
list. Look for examples at `visfilt-filter-list' and
`visfilt-filter-buffer'.

TODO: this is currently an internal variable. Make it so that
this could be set outside visfilt to support filtering of
different types of `elements'.
")

(defvar visfilt-displayed-elements nil)

(defvar visfilt-mode-map
  nil
  "Keymap for visfilt mode.")

;; core functionality

(defun visfilt-regenerate-keymap() 
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)

    (define-key map (kbd "C-g") 'kill-this-buffer)
    (define-key map (kbd "<RET>") 'visfilt-run-callback)
    (define-key map (kbd "<backspace>") 'visfilt-search-string-decrement)

    (dolist (k (string-to-list visfilt-search-key-list))
      (define-key map (read-kbd-macro (char-to-string k))
	'visfilt-search-string-modify))

    (setq visfilt-mode-map map)))

;; generate the keymap for the first time
(visfilt-regenerate-keymap)

(defun visfilt-header-default-format-function (&optional searchstr count)
  (if (and (null searchstr) (null count))
      2
    (format "String(%d): %s\n" count searchstr)))

(defun visfilt-run-callback ()
  "When an element is selected, this function runs the callback
function that is stored in `visfilt-choose-callback'."

  (interactive)
  (let ((string (filter-buffer-substring (point-at-bol) (point-at-eol)))
	(callback visfilt-choose-callback)
	(pos (line-number-at-pos))
	(elem (nth (- (line-number-at-pos) (funcall visfilt-header-format-function)) 
		   visfilt-displayed-elements)))

    (kill-buffer (current-buffer))
    (when (functionp callback)
      ;; (message "current line %d ja tällöin %s" pos elem)
      (funcall callback elem))))

(defun visfilt-update ()
  "Updates the visfilt buffer with a search string."
  (erase-buffer)
  (let* ((max-items (or visfilt-max-items 
			(- (window-height) 1 
			   (funcall visfilt-header-format-function))))
	 (displayed 
	  (funcall visfilt-choose-filter-function 
		   visfilt-search-data max-items 
		   (visfilt-escape-re visfilt-search-string)))
	 start-point)

    ;; insert the header
    (insert (funcall visfilt-header-format-function 
		     (visfilt-escape-re visfilt-search-string) (length displayed)))
    (setq start-point (point))

    (setq visfilt-displayed-elements displayed)

    ;; insert the filtered elements
    (dolist (line displayed)
      (insert (concat (funcall visfilt-display-line-function line) "\n")))

    ;; apply the font-face
    (set-buffer-modified-p nil)
    (goto-char (point-min))
    (if (> (length visfilt-search-string) 0)
	(hi-lock-face-buffer 
	 visfilt-search-string visfilt-search-string-face))
    (goto-char start-point)))

(defun visfilt-escape-re (string)
  "Escape regular expression syntax in a string"
  (mapconcat #'(lambda (x)
		(setq x (char-to-string x))
		(if (string-match "[.+?|*\\^$[]" x)
		    (concat "\\" x)
		  x))
	     string ""))

(defun visfilt-search-string-modify (&optional decrement)
  "Either adds the `last-command-event' as a string to the search
string or if decrement is not nil, then removes one character. In any case
removes the previous search string overlay face."
  (interactive)

  (if (> (length visfilt-search-string) 0)
      (hi-lock-unface-buffer visfilt-search-string))
  (if decrement
      (let ((len (length visfilt-search-string)))
	(if (> len 0)
	    (setq visfilt-search-string 
		  (subseq visfilt-search-string 0 
			  (min (- len 1) len)))))
    (setq visfilt-search-string (concat visfilt-search-string 
					(char-to-string last-command-event))))
  (visfilt-update))

(defun visfilt-search-string-decrement ()
  "Decrements the visfilt-search-string by one character." 
  (interactive)
  (visfilt-search-string-modify t))

(define-derived-mode visfilt-mode nil "Visual list"
  "Visual list mode.
  \\{visfilt-mode-map}"
)

(defun visfilt-choose (elements callback)
  "Choose an element from `elements' using visfilt and return the
element through callback `callback'. "
  (interactive)

  (cond 
   ((listp elements)
    (setq visfilt-choose-filter-function 'visfilt-filter-list))
   ((or (stringp elements) (bufferp elements))
    (setq visfilt-choose-filter-function 'visfilt-filter-buffer)
    (if (stringp elements)
	(setq elements (get-buffer elements))))

   (t 
    (error "unsupported type for the first argument"))
   )


  (switch-to-buffer (get-buffer-create (generate-new-buffer-name visfilt-buffer-name)) t)
  (visfilt-mode)

  (make-local-variable 'visfilt-mode-map)
  (make-local-variable 'visfilt-search-string)
  (make-local-variable 'visfilt-search-data)
  (make-local-variable 'visfilt-search-data-pos)
  (make-local-variable 'visfilt-choose-callback)
  (make-local-variable 'visfilt-choose-filter-function)
  (make-local-variable 'visfilt-displayed-elements)
  (make-local-variable 'visfilt-display-line-function)

  (visfilt-regenerate-keymap)
  (use-local-map visfilt-mode-map)

  (setq visfilt-search-string "")
  (setq visfilt-search-data elements)
  (setq visfilt-choose-callback callback)

  (setq truncate-lines t)

  ;; (message "callback on täällä %s" callback)
  (hi-lock-mode 1)
  (visfilt-update))


;; peripheral functionality

;;TODO ekassa tapauksessa formaatti myös oikeaksi
(defun visfilt-filter-list (elements count search-str)
  "Filters a list with the `search-str'."
  (if (>= (length visfilt-search-string) 0)
      (let (matched (pos 0))
	(every  '(lambda (x) 
		   (when (string-match search-str x)
		     (push (list x pos) matched)
		     (setq count (1- count)))
		   (setq pos (1+ pos))
		   (if (<= count 0)
		       nil
		     t))
		elements)
	matched)
    (subseq visfilt-search-data 0 count)))

;; move-to-window-line 0
;; line-number-at-pos 

(defun visfilt-filter-buffer (buffer count search-str)
  "Filters a buffer with the `search-str'."
  (let (ret)
    (with-current-buffer buffer
      (goto-char (point-min))
      (when (> (length search-str) 0)
	(while (> count 0)
	  (let ((pos (re-search-forward search-str nil t nil)))
	    (if pos
		(add-to-list 'ret 
			     (list (buffer-substring (point-at-bol) (point-at-eol))
				   (line-number-at-pos)) t)
	      (setq count 0))
	    (setq count (1- count))
	    )))
      ret)))


(provide 'visfilt)
